## Simple Introduction of gRPC

gRPC is called as `gRPC Remote Procedure Call`

- Its strictly typed 
- highly performant, scalable and interopable 
- By default it uses HTTP2 as transport layer
   - HTTP2 is a binary protocol
   - Note: when using telnet to connect to a port, when we issue GET the response is test, but in http2 it is binary. The Get/Put/etc. are encrypted (1 byte)
   - Header are compressed, the content pay load will have many headers.
- It make streaming as first class citizen (it can multiplex multiple connection)

- Based on IDL (Interface Defintion Language)
- uses protobuf version 3

gRPC -is efficient per cpu compared to the text based on protocol.

Simple: grpc-server
 - To create the server we need to define the IDL.
 - In gRPC the IDL supported is protobuf 3


## Creating a simple gRPC server, work flow by creating the IDL (proto file) and generating stub code and defining the server by implenting the service.

Step 1: create the IDL define it in a proto file

```
# This will set to use the protbuf version 3

syntax = "proto3"

# we define package, any code generated by the generator will
# be created in this package

package com.grpc.example;

# in order to compile the IDL into actual code, we need to run
# it through a generator called proto gen compiler.
# we use options to tell genertor compiler with option
# say in java the proto gen compiler creates the code into
# single file, we can tell using option to create multiple files

option java_multiple_files = true;

# We can define enum like java in here

enum Wishtype{
    WELCOME = 0;
    HELLO = 1;
}

# we need to define the payload first.
# in gRPC we need to define the request and the response.
# Rather than writting the class, we use the keyword message

# below will create the payload, this will create a pojo
# called HelloRequest and with the properties inside

## in the below message we can define properties
message HelloRequest{

# we define what attributes we need
# the attributes are strongly typed so we provide a type
# in addition to there is an tag (1), this is a binary
# representation of the field in the payload.
# Note that, in the Json we use actual string userName we 
# to identify the field since gRPC is binary we need the tag
# to identify the specific field.

# Important:
# If the tag number is less than 16, it will take a byte
# if the number is greater than 16 it will use more than a byte
# For fequently used fields use lower number as tags.
# Using lower number in tag, will be more efficient.

  string userName = 1; 
  string message = 2;
  int64 id = 3;
  
  # we can also define enums in the IDL, 
  # define the enum like the above Wishtype, we can use it
  Wishtype wishtype = 4;
  
  # we can also create arrays or list
  repeated string wishes = 5;
  
  # strongly type map with strongly type key and value
  map<string, string> itemsPicked = 6;
  
}

## note the above is IDL defined it is interopable in different languages
## that is strongly typed language like java, etc.


# we define the response payload now below 

message HelloResponse{
  string greetings = 1;
}

# We define the service

service WishService{

# within this service we can define the operation using rpc keyword
   rpc wish(HelloRequest) returns (HelloResponse);
}

## Below is just for demonstrating the use of additional option
## This can be removed if we are creating the grpc server

# Say for example if we wanted to create a streaming service
# then we need to add a stream in the operation like below

service WishStreamService{
  rpc wishStream(stream HelloRequest) returns (HelloResponse);
}

# in the above if we need to stream the response continously 
# say we need to stream data from client to server we define it like below

service WishStreamService{
  rpc wishStream(HelloRequest) returns (stream HelloResponse);
}

# creating a bi-directional like chat application we need to define like below

service WishStreamService{
  rpc wishStream(stream HelloRequest) returns (stream HelloResponse);
}
```

Step 2: Since we are using java, we need to compile the IDL to java code.
- we use the maven command. (earlier we need to use the protoc compiler, we need to choose the corresponding version, but now this is simplified.)


For dependecies include the maven dependecies form this [link](https://github.com/grpc/grpc-java)

```
<dependency>
  <groupId>io.grpc</groupId>
  <artifactId>grpc-netty-shaded</artifactId>
  <version>1.50.0</version>
  <scope>runtime</scope>
</dependency>
<dependency>
  <groupId>io.grpc</groupId>
  <artifactId>grpc-protobuf</artifactId>
  <version>1.50.0</version>
</dependency>
<dependency>
  <groupId>io.grpc</groupId>
  <artifactId>grpc-stub</artifactId>
  <version>1.50.0</version>
</dependency>
<dependency> <!-- necessary for Java 9+ -->
  <groupId>org.apache.tomcat</groupId>
  <artifactId>annotations-api</artifactId>
  <version>6.0.53</version>
  <scope>provided</scope>
</dependency>
```

- Add the maven plugin
  - Below dependecies is figuring out the operating system we are using and 
  - download the protoc compiler based on the architecture of the OS and 
  - hooks it in the phases in the build, so when we do maven build, package the stub will be generated
  
```
<build>
  <extensions>
    <extension>
      <groupId>kr.motd.maven</groupId>
      <artifactId>os-maven-plugin</artifactId>
      <version>1.6.2</version>
    </extension>
  </extensions>
  <plugins>
    <plugin>
      <groupId>org.xolstice.maven.plugins</groupId>
      <artifactId>protobuf-maven-plugin</artifactId>
      <version>0.6.1</version>
      <configuration>
        <protocArtifact>com.google.protobuf:protoc:3.21.7:exe:${os.detected.classifier}</protocArtifact>
        <pluginId>grpc-java</pluginId>
        <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.50.0:exe:${os.detected.classifier}</pluginArtifact>
      </configuration>
      <executions>
        <execution>
          <goals>
            <goal>compile</goal>
            <goal>compile-custom</goal>
          </goals>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
```

- Step 3: Run maven command 
```
mvn clean pacakge
```
  - This will create the source in the /target/generated-sources/protobuf/grpc-java/ folder.
  - The above mentioned folder will have the package mentioned in the IDL and the java files created in it.

- Step 4: We can implement the Stub now.
  - Create a java class
  
```java

package com.grpc.example.server

public class WishServiceImpl extend WishServiceGrpc.WishServiceImplBase{
    //override the grpc operation we defined
    
    //in normal java definition an unary operation will be taking a value and returns 
    // a value and the signature looks like 
    // public HelloResponse wish(HelloRequest request ){ ....}
    
    // below is uniary request, below is more reactive
    // Everything on the grpc server is asynchronous by default
    
    // to make this to be sychronoized or blocked it can be done 
    // from the client 
    
    // important: the gRPC server is built to be asynchronous 
    // it is upto the client to decide it to make is synchoronous or not
   
    @Override
    public void wish(HelloRequest request, StreamObserver<HelloResponse> responseObserver){
       // in order to get the response to the client we need to use the observer
       
       // Below is more reactive programming of java (using onNext(), onComplete(), etc)
       // Note: All the object in gRPC used builder pattern
       
       responseObserver.onNext(HelloResponse.newBuilder()
       .setMessage("Hello " +request.getUserName())
       .build());
       // note when using the onNext(), only one message is sent to
       // the client, the stream is still opened, we need to explictly
       // close the stream
       
       responseObserver.onCompleted();
    }
}
```
- Step 5: we need to create the server (or deploy the service in the server)
  - we need to deploy the service into a container where we expose the port
  - The server used here, uses Netty server under the hood, since it uses the http2

```

package com.grpc.example.server;


public class ExampleGrpcServer{

 public static void main (String ... str){
    // implementation server
    // create a server using serverbuilder
    // add or register the handler service to the grpc

    Server server = ServerBuilder.forPort(8080)
    .addService(new WishServiceImpl) 
    .build();
    
    // start the server
    server.start();
    
    // this is necessary since the server will be running in different
    // thread, if we don't await the main thread will stop the process immediately
    server.awaitTermination(); 
 }
}
```
- Step 6: Run the code

```
mvn install exec:java -Dexec.mainClass=com.grpc.example.server.ExampleGrpcServer
```
