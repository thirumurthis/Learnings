### Parallel vs Sequence:
  - To run github action job or step in sequential we use `needs` 

- Context and expression:
  - To output github contexts 

  ```yaml
   name: Github context info
   on: workflow_dispatch
   jobs: 
     output-info:
       runs-on: ubuntu-latest
       steps:
        - name: Output Github context
          run: echo "${{ toJSON(github) }}"  # github is reserved key name we use github action function
  ```


> Info:
> - If we have a local git repo for a project, and we need to associate to the github repository newly created in github UI. Then using `git remote add origin https://<username>@github.com/<username>/new-git-repo`


### Events:
  - Available events 
     - Repository releated - mostly like push, pull_request, create, fork, issues, watch, discussions, issue_comment, etc
     - Other Events - workflow_dispatch, repository_dispatch, schedule, workflow_call, etc 
  - Refer the github documentation for more events.

  - To utlized more than one event for job we can use yaml list

  ```yaml
  name: Events info
  on: [push, workflow_dispatch]
  jobs:
    deploy:
      runs-on: ubuntu-latest
      steps:
       - name: Output event context
         run: echo "${{ toJSON(github.event) }}"
  ``` 
- Event Activity Types and Filters:
  - If we want more control, like if trigger only on specific branch we might use the activity types of that event.
  - We can use filters as well to control the trigger.
     - Sample push filter `on.push.<branches|tags|branches-ignore|tags-ignore>`
     - Sample push filter `on.<push|pull_request|pull_request_target>.<paths|paths-ignore>
  - Check documentation for more activites on the event.
  - For example, the Pull event has activity types - open, closed, edited.
  - For example, the push event has filters based on target branch.

  ```yaml
   name: Events Sample
   on:
     pull_request:
      types:
        - opened
        - closed
      branches: # specify the branch trigger only for listed branch or expression
        - main
        - PR-*  # branch starts with PR-, ex. PR-000-test
        - feature/**  # ** allows / after the feature/, ex- feature/test/one
     workflow_dispatch:
     push:
       branches: # specify the branch trigger only for listed branch or expression
        - main
        - PR-*  # branch starts with PR-, ex. PR-000-test
        - feature/**  # ** allows / after the feature/, ex- feature/test/one
       paths:
         - '**.java'  # This indicates the workflow will be triggered only if on of the java file is updated
       paths-ignore:
         - '.github/workflows/*'

   jobs:
     deploy:
      runs-on: ubuntu-latest
      steps:
        - name: Output info
          run: echo "$ {{ toJSON(github.event) }}"
  ```

  - Skipping the CI when we use the push or pull events
   - Say if we are making changes to the code just on the comment we might not need the Github actions workflow to be executed. In that case when we commit the code, we can use `[skipt ci]`,`[ci skip]`,`[no ci]`,`[skip actions]`,`[actions skip]`. Alternatively, we can add the following at the end of the commit with 2 empty lines. `skip-checks:true`, `skip-checks: true`.

#### Job Data & outputs 
- Working with artifact
- Working with job outputs
- Caching Dependencies

  - Lets say of a job that build a website will produce an output. The output could be executable or other formats, or to be uploaded to appstore/artifactory. The output generated by the job is called output assests. The artifacts can be stored manually or automatically.


  ```yaml
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: Test code
          run: npm run test
    build:
      needs: test
      runs-on: ubuntu-latest
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
             package.json  # this is an example
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files # the build artifact is zip this will unzip 
       - name: list the content
         run: ls -lrth
       - name: deploy
         run: echo "deploy.."
  ```
   - under the github actions, we should be able to see the artifacts section with artifact to download in local.

   - Note the artifacts produced by the build job is not available to deploy job. Since both runs on different machines

   - To download we need to use the action `download-artifacts`

#### Job outputs to be available to other jobs

- Say the artifact name of a file created in `build` job to be available in `deploy` job below.

   - To do this we can use the feature, in the `build` job after the building we meed to get the javascript name.
     ```
     ...
     - name: Publish JS name
       run: find dist/assets/*.js -type -f -execdir echo '{}' ';' # ouputs the file name
     ```
     - The above only get the file name, it is still not usable by other job
     - To configure the filename in an variable, we first need to define a section under the `build` job called `outputs`
    
     ```
     ...
     build:
       needs: test
       runs-on: ubuntu-latest
       outputs:  # this section should be added 
          script-file:   # variable in which the filename value to be stored
     ```
     - With the output defined we need to set the `script-file` value
    
     ```
     ...
     - name: Publish JS name
       run: find dist/assets/*.js -type -f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';' # the script-file=<file-name> will be send to special github output  variable 
     ```
     - The `outputs` section value should get the value from the context, here we use `steps` context and  the output of that steps. But note we can't access directly with the name of the step in this case `Publish Js Filename`, we need to add a id for the step.
    
     ```
     ...
     build:
       ...
       outputs:
          script-file: ${{ steps.publish.outputs.script-file }}
       steps:
         ...
         - name: Publush JS filename
           id: publish  # step id for output info 
           run: find dist/assets/*.js -type -f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'   # note the script-file name can be anything but match the section in the output fetched from step.
     ```
     - Till above we have published the output from `step` to the `job`. Now to access the output of `build` job in `deploy` job

     ```
     deploy:
       ....
       - name: ouput filename
         run: echo "${{ needs.build.outputs.script-file }}"  # we can use jobs context as well to get the output value in here we use needs (check the doc) [needs.<job-name>.outputs.<output-variable-defined-in-build-job>]
     ```
       

  ```yaml
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: Test code
          run: npm run test
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish  # this is required so the output will use it
         # the outputs above we have set the script-file variable.
         # GITHUB_OUTPUT is a special variable
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'
         # alternatively we can use below without use of GITHUB_OUTPUT. Below was old way to do but as best practice use above github_output approach
         #run: find dist/assets/*.js -type f -execdir echo '::set-output name=script-file::{}' ';'
       - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
             package.json  # this is an example
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files # the build artifact is zip this will unzip 
       - name: list the content
         run: ls -lrth
       - name: Output the filename from build job
         # we use needs object check doc, since this contains ouput of all the jobs needs.<job-name>.output.<variable>
         run: echo "${{ needs.build.outputs.script-file }}
       - name: deploy
         run: echo "deploy.."
  ```

### Depenency caching
- The depnedncies can be cached from one job to another job. Refer the above the build and test has the install dependency.
- we can use `action/cache@v4`

```yaml
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}  # used to retreive and cached in runner instance
             # hasFiles function will generate has when the files are changed.
             # when the package.json file change, then different hash key will be different so chace will not be used and install dependencies will install new dependencies.
             # after the job is completed, the cache will be updated for new dependency
             # different project has different cache option refer document.
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: Test code
          run: npm run test
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}         
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish  # this is required so the output will use it
         # the outputs above we have set the script-file variable.
         # GITHUB_OUTPUT is a special variable
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'
         # alternatively we can use below without use of GITHUB_OUTPUT. Below was old way to do but as best practice use above github_output approach
         #run: find dist/assets/*.js -type f -execdir echo '::set-output name=script-file::{}' ';'
       - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
             package.json  # this is an example
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files # the build artifact is zip this will unzip 
       - name: list the content
         run: ls -lrth
       - name: Output the filename from build job
         # we use needs object check doc, since this contains output of all the jobs needs.<job-name>.output.<variable>
         run: echo "${{ needs.build.outputs.script-file }}
       - name: deploy
         run: echo "deploy.."
```

### Conditional in jobs & Steps

- Adding condition to the steps, lets add a test report upload step. The test.json generation is configured in the npm build within the code.
   - If the `test code` step fails the `upload test report` step is not required to be executed.

```
   - **NOTE**: In general, the default behaviour is the dependent jobs (that uses "needs") would be cancelled/aborted if the previous job fails.
```

   - To add the condition and refer the steps execution state we can add an `id` field for the step that we will be using in the if condition.

``` 
   - **Note**, in if condition we can ommit the use of `${{ }}`. This is applicable only for `if`
```

    - The `steps.<step_id>.conclusion` or `steps.<step_id>.outcome` can be used in the `if` condition. Refer the document. The `outcome` returns the string with the status.

    - condition example below the `upload test report` will be enabled only when the `test code` fails.
    - with just the `if: steps.run-test.outcome == 'failure'` condition the default behaviour will not be override. That is if the steps failed following steps and dependent job will fail.
    - In order to override the default behaviour we use a function `failure()` like in below

    `if: failure() && steps.run-test.outcome == 'failure'`
 
  **NOTE:** Github action has four function to be used within the if condition. 
    - `failure()` => returns true if previous step or job failed
    - `success()` => returns true if previous step or job complete
    - `always()` => causes the step to always execute even when cancelled
    - `cancelled()` => returns true if workflow cancelled

```yaml
   #...
        - name: test code
          id: run-test
          run: npm run test  
        - name: Upload test report
          if: failure() && steps.run-test.outcome == 'failure'
          uses: actions/upload-artifact@v4
          with:
            name: test-report
            path: test.json
```

```yaml
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: test code
          id: run-test
          run: npm run test  
        - name: Upload test report
          if: failure() && steps.run-test.outcome == 'failure'
          uses: actions/upload-artifact@v4
          with:
            name: test-report
            path: test.json
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}         
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish 
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'       
         - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files
       - name: list the content
         run: ls -lrth
       - name: Output the filename from build job
         run: echo "${{ needs.build.outputs.script-file }}
       - name: deploy
         run: echo "deploy.."
```

  - The `if` condition can also be added at the job level
  - refer the `report` job added to the end. which will run when there is failure.
  - If the job is executed in parallel, then the `report` job will be skipped.
  - we need to add dependency of `report` to the `lint` and `deploy`. which will wait for the previous job to start and complete.
  - Note the `test` and `lint` job starts parallel. 

  ```yaml
  
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    lint: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint          
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: test code
          id: run-test
          run: npm run test  
        - name: Upload test report
          if: failure() && steps.run-test.outcome == 'failure'
          uses: actions/upload-artifact@v4
          with:
            name: test-report
            path: test.json
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}         
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish 
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'       
         - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files
       - name: list the content
         run: ls -lrth
       - name: Output the filename from build job
         run: echo "${{ needs.build.outputs.script-file }}
       - name: deploy
         run: echo "deploy.."

    report:
      needs: [lint, deploy]
      if: failure()
      runs-on: ubuntu-latest
      steps:
       - name: Output report
         run: |
           echo "something went wrong"
           echo "${{ github }}"
  ```

  #### Running job with matrix

  - The idea of matrix, is the run the same job with different configuration. Like different `runners` and different `node versions` referring to below example workflow.
   - The key under the `matrix` is totally arbitary it can be any name.

  ```
  ...
          strategy:
          matrix:
             node-version: [12,14,16]
             operating-system: [ubuntu-latest, windows-latest]
  ```

  - The `runs-on: ${{ matrix.operating-system }}` will run the job on different values on the `matrix` variable. These job will be executed in parallel by default.
  - This matrix can be used in steps and jobs

  - Scenario, if we need to run the test in different os.

  ```yaml 
  name: Matrix demo
  on: push
  jobs:
     build:
        strategy:
          matrix:
             node-version: [12,14,16]
             operating-system: [ubuntu-latest, windows-latest]
        #runs-on: ubuntu-latest # <--- this will change to 
        runs-on: ${{ matrix.operating-system }}
        steps:
         - name: get code
           uses: actions/checkout@v4
         - name: Install nodeJS
           uses: actions/setup-node@v4
           with:
              # node-version: 16  # <-- this will change 
              node-version: ${{ matrix.node-version }} 
         - name: Install dependencies
           run: npm ci
         - name: Build project
           run: npm run build
  ```

**NOTE**: The jobs will start in parallel and if any job fails then it will skip or abort the other jobs. In order to overcome this behaviour we can add `continue-on-error: true` under the job `build` like below.

```yaml
  name: Matrix demo
  on: push
  jobs:
     build:
        continue-on-error: true
        strategy:
```
#### includes and excludes in matrix

  - Along with the set of combination say in below example we are runign the `node-version` and `operating-system` we need to include one more combination then we can use the `include` key like below. Allows to provide standalone combination.
  - `exclude` the combination in below example will exclude the node 12 with windows job to be executed.
  
  ```yaml 
  name: Matrix demo
  on: push
  jobs:
     build:
        strategy:
          matrix:
             node-version: [12,14,16]
             operating-system: [ubuntu-latest, windows-latest]
             include:
               - node-version: 18
                 operating-system: ubuntu-latest
             exclude:
                - node-version: 12
                  operating-system: windows-latest
        runs-on: ${{ matrix.operating-system }}
        steps:
         - name: get code
           uses: actions/checkout@v4
         - name: Install nodeJS
           uses: actions/setup-node@v4
           with:
              # node-version: 16  # <-- this will change 
              node-version: ${{ matrix.node-version }} 
         - name: Install dependencies
           run: npm ci
         - name: Build project
           run: npm run build
  ```

   