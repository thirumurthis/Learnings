### Parallel vs Sequence:
  - To run github action job or step in sequential we use `needs` 

- Context and expression:
  - To output github contexts 

  ```yaml
   name: Github context info
   on: workflow_dispatch
   jobs: 
     output-info:
       runs-on: ubuntu-latest
       steps:
        - name: Output Github context
          run: echo "${{ toJSON(github) }}"  # github is reserved key name we use github action function
  ```


> Info:
> - If we have a local git repo for a project, and we need to associate to the github repository newly created in github UI. Then using `git remote add origin https://<username>@github.com/<username>/new-git-repo`


### Events:
  - Available events 
     - Repository releated - mostly like push, pull_request, create, fork, issues, watch, discussions, issue_comment, etc
     - Other Events - workflow_dispatch, repository_dispatch, schedule, workflow_call, etc 
  - Refer the github documentation for more events.

  - To utlized more than one event for job we can use yaml list

  ```yaml
  name: Events info
  on: [push, workflow_dispatch]
  jobs:
    deploy:
      runs-on: ubuntu-latest
      steps:
       - name: Output event context
         run: echo "${{ toJSON(github.event) }}"
  ``` 
- Event Activity Types and Filters:
  - If we want more control, like if trigger only on specific branch we might use the activity types of that event.
  - We can use filters as well to control the trigger.
     - Sample push filter `on.push.<branches|tags|branches-ignore|tags-ignore>`
     - Sample push filter `on.<push|pull_request|pull_request_target>.<paths|paths-ignore>
  - Check documentation for more activites on the event.
  - For example, the Pull event has activity types - open, closed, edited.
  - For example, the push event has filters based on target branch.

  ```yaml
   name: Events Sample
   on:
     pull_request:
      types:
        - opened
        - closed
      branches: # specify the branch trigger only for listed branch or expression
        - main
        - PR-*  # branch starts with PR-, ex. PR-000-test
        - feature/**  # ** allows / after the feature/, ex- feature/test/one
     workflow_dispatch:
     push:
       branches: # specify the branch trigger only for listed branch or expression
        - main
        - PR-*  # branch starts with PR-, ex. PR-000-test
        - feature/**  # ** allows / after the feature/, ex- feature/test/one
       paths:
         - '**.java'  # This indicates the workflow will be triggered only if on of the java file is updated
       paths-ignore:
         - '.github/workflows/*'

   jobs:
     deploy:
      runs-on: ubuntu-latest
      steps:
        - name: Output info
          run: echo "$ {{ toJSON(github.event) }}"
  ```

  - Skipping the CI when we use the push or pull events
   - Say if we are making changes to the code just on the comment we might not need the Github actions workflow to be executed. In that case when we commit the code, we can use `[skipt ci]`,`[ci skip]`,`[no ci]`,`[skip actions]`,`[actions skip]`. Alternatively, we can add the following at the end of the commit with 2 empty lines. `skip-checks:true`, `skip-checks: true`.

#### Job Data & outputs 
- Working with artifact
- Working with job outputs
- Caching Dependencies

  - Lets say of a job that build a website will produce an output. The output could be executable or other formats, or to be uploaded to appstore/artifactory. The output generated by the job is called output assests. The artifacts can be stored manually or automatically.


  ```yaml
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: Test code
          run: npm run test
    build:
      needs: test
      runs-on: ubuntu-latest
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
             package.json  # this is an example
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files # the build artifact is zip this will unzip 
       - name: list the content
         run: ls -lrth
       - name: deploy
         run: echo "deploy.."
  ```
   - under the github actions, we should be able to see the artifacts section with artifact to download in local.

   - Note the artifacts produced by the build job is not available to deploy job. Since both runs on different machines

   - To download we need to use the action `download-artifacts`

#### Job outputs to be available to other jobs

- Say the artifact name of a file created in `build` job to be available in `deploy` job below.

   - To do this we can use the feature, in the `build` job after the building we meed to get the javascript name.
     ```
     ...
     - name: Publish JS name
       run: find dist/assets/*.js -type -f -execdir echo '{}' ';' # ouputs the file name
     ```
     - The above only get the file name, it is still not usable by other job
     - To configure the filename in an variable, we first need to define a section under the `build` job called `outputs`
    
     ```
     ...
     build:
       needs: test
       runs-on: ubuntu-latest
       outputs:  # this section should be added 
          script-file:   # variable in which the filename value to be stored
     ```
     - With the output defined we need to set the `script-file` value
    
     ```
     ...
     - name: Publish JS name
       run: find dist/assets/*.js -type -f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';' # the script-file=<file-name> will be send to special github output  variable 
     ```
     - The `outputs` section value should get the value from the context, here we use `steps` context and  the output of that steps. But note we can't access directly with the name of the step in this case `Publish Js Filename`, we need to add a id for the step.
    
     ```
     ...
     build:
       ...
       outputs:
          script-file: ${{ steps.publish.outputs.script-file }}
       steps:
         ...
         - name: Publush JS filename
           id: publish  # step id for output info 
           run: find dist/assets/*.js -type -f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'   # note the script-file name can be anything but match the section in the output fetched from step.
     ```
     - Till above we have published the output from `step` to the `job`. Now to access the output of `build` job in `deploy` job

     ```
     deploy:
       ....
       - name: ouput filename
         run: echo "${{ needs.build.outputs.script-file }}"  # we can use jobs context as well to get the output value in here we use needs (check the doc) [needs.<job-name>.outputs.<output-variable-defined-in-build-job>]
     ```
       

  ```yaml
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: Test code
          run: npm run test
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish  # this is required so the output will use it
         # the outputs above we have set the script-file variable.
         # GITHUB_OUTPUT is a special variable
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'
         # alternatively we can use below without use of GITHUB_OUTPUT. Below was old way to do but as best practice use above github_output approach
         #run: find dist/assets/*.js -type f -execdir echo '::set-output name=script-file::{}' ';'
       - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
             package.json  # this is an example
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files # the build artifact is zip this will unzip 
       - name: list the content
         run: ls -lrth
       - name: Output the filename from build job
         # we use needs object check doc, since this contains ouput of all the jobs needs.<job-name>.output.<variable>
         run: echo "${{ needs.build.outputs.script-file }}
       - name: deploy
         run: echo "deploy.."
  ```

### Depenency caching
- The depnedncies can be cached from one job to another job. Refer the above the build and test has the install dependency.
- we can use `action/cache@v4`

```yaml
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}  # used to retreive and cached in runner instance
             # hasFiles function will generate has when the files are changed.
             # when the package.json file change, then different hash key will be different so chace will not be used and install dependencies will install new dependencies.
             # after the job is completed, the cache will be updated for new dependency
             # different project has different cache option refer document.
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: Test code
          run: npm run test
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}         
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish  # this is required so the output will use it
         # the outputs above we have set the script-file variable.
         # GITHUB_OUTPUT is a special variable
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'
         # alternatively we can use below without use of GITHUB_OUTPUT. Below was old way to do but as best practice use above github_output approach
         #run: find dist/assets/*.js -type f -execdir echo '::set-output name=script-file::{}' ';'
       - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
             package.json  # this is an example
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files # the build artifact is zip this will unzip 
       - name: list the content
         run: ls -lrth
       - name: Output the filename from build job
         # we use needs object check doc, since this contains output of all the jobs needs.<job-name>.output.<variable>
         run: echo "${{ needs.build.outputs.script-file }}
       - name: deploy
         run: echo "deploy.."
```

### Conditional in jobs & Steps

- Adding condition to the steps, lets add a test report upload step. The test.json generation is configured in the npm build within the code.
   - If the `test code` step fails the `upload test report` step is not required to be executed.

```
   - **NOTE**: In general, the default behaviour is the dependent jobs (that uses "needs") would be cancelled/aborted if the previous job fails.
```

   - To add the condition and refer the steps execution state we can add an `id` field for the step that we will be using in the if condition.

``` 
   - **Note**, in if condition we can ommit the use of `${{ }}`. This is applicable only for `if`
```

    - The `steps.<step_id>.conclusion` or `steps.<step_id>.outcome` can be used in the `if` condition. Refer the document. The `outcome` returns the string with the status.

    - condition example below the `upload test report` will be enabled only when the `test code` fails.
    - with just the `if: steps.run-test.outcome == 'failure'` condition the default behaviour will not be override. That is if the steps failed following steps and dependent job will fail.
    - In order to override the default behaviour we use a function `failure()` like in below

    `if: failure() && steps.run-test.outcome == 'failure'`
 
  **NOTE:** Github action has four function to be used within the if condition. 
    - `failure()` => returns true if previous step or job failed
    - `success()` => returns true if previous step or job complete
    - `always()` => causes the step to always execute even when cancelled
    - `cancelled()` => returns true if workflow cancelled

```yaml
   #...
        - name: test code
          id: run-test
          run: npm run test  
        - name: Upload test report
          if: failure() && steps.run-test.outcome == 'failure'
          uses: actions/upload-artifact@v4
          with:
            name: test-report
            path: test.json
```

```yaml
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: test code
          id: run-test
          run: npm run test  
        - name: Upload test report
          if: failure() && steps.run-test.outcome == 'failure'
          uses: actions/upload-artifact@v4
          with:
            name: test-report
            path: test.json
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}         
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish 
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'       
         - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files
       - name: list the content
         run: ls -lrth
       - name: Output the filename from build job
         run: echo "${{ needs.build.outputs.script-file }}
       - name: deploy
         run: echo "deploy.."
```

  - The `if` condition can also be added at the job level
  - refer the `report` job added to the end. which will run when there is failure.
  - If the job is executed in parallel, then the `report` job will be skipped.
  - we need to add dependency of `report` to the `lint` and `deploy`. which will wait for the previous job to start and complete.
  - Note the `test` and `lint` job starts parallel. 

  ```yaml
  
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    lint: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint          
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: test code
          id: run-test
          run: npm run test  
        - name: Upload test report
          if: failure() && steps.run-test.outcome == 'failure'
          uses: actions/upload-artifact@v4
          with:
            name: test-report
            path: test.json
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}         
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish 
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'       
         - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files
       - name: list the content
         run: ls -lrth
       - name: Output the filename from build job
         run: echo "${{ needs.build.outputs.script-file }}
       - name: deploy
         run: echo "deploy.."

    report:
      needs: [lint, deploy]
      if: failure()
      runs-on: ubuntu-latest
      steps:
       - name: Output report
         run: |
           echo "something went wrong"
           echo "${{ github }}"
  ```

  #### Running job with matrix

  - The idea of matrix, is the run the same job with different configuration. Like different `runners` and different `node versions` referring to below example workflow.
   - The key under the `matrix` is totally arbitary it can be any name.

  ```
  ...
          strategy:
          matrix:
             node-version: [12,14,16]
             operating-system: [ubuntu-latest, windows-latest]
  ```

  - The `runs-on: ${{ matrix.operating-system }}` will run the job on different values on the `matrix` variable. These job will be executed in parallel by default.
  - This matrix can be used in steps and jobs

  - Scenario, if we need to run the test in different os.

  ```yaml 
  name: Matrix demo
  on: push
  jobs:
     build:
        strategy:
          matrix:
             node-version: [12,14,16]
             operating-system: [ubuntu-latest, windows-latest]
        #runs-on: ubuntu-latest # <--- this will change to 
        runs-on: ${{ matrix.operating-system }}
        steps:
         - name: get code
           uses: actions/checkout@v4
         - name: Install nodeJS
           uses: actions/setup-node@v4
           with:
              # node-version: 16  # <-- this will change 
              node-version: ${{ matrix.node-version }} 
         - name: Install dependencies
           run: npm ci
         - name: Build project
           run: npm run build
  ```

**NOTE**: The jobs will start in parallel and if any job fails then it will skip or abort the other jobs. In order to overcome this behaviour we can add `continue-on-error: true` under the job `build` like below.

```yaml
  name: Matrix demo
  on: push
  jobs:
     build:
        continue-on-error: true
        strategy:
```
#### includes and excludes in matrix

  - Along with the set of combination say in below example we are runign the `node-version` and `operating-system` we need to include one more combination then we can use the `include` key like below. Allows to provide standalone combination.
  - `exclude` the combination in below example will exclude the node 12 with windows job to be executed.
  
  ```yaml 
  name: Matrix demo
  on: push
  jobs:
     build:
        strategy:
          matrix:
             node-version: [12,14,16]
             operating-system: [ubuntu-latest, windows-latest]
             include:
               - node-version: 18
                 operating-system: ubuntu-latest
             exclude:
                - node-version: 12
                  operating-system: windows-latest
        runs-on: ${{ matrix.operating-system }}
        steps:
         - name: get code
           uses: actions/checkout@v4
         - name: Install nodeJS
           uses: actions/setup-node@v4
           with:
              # node-version: 16  # <-- this will change 
              node-version: ${{ matrix.node-version }} 
         - name: Install dependencies
           run: npm ci
         - name: Build project
           run: npm run build
  ```

#### Reusable workflow

- Using the workflow_call 

  ```yaml
  name: Reusable workflow deploy
  on: workflow_call
  jobs:
    deploy:
      runs-on: ubuntu-latest
      steps:
      - name: Output info
        run: echo "deploy & upload"
  ```

  The above code can be used in the deploy job as defined above sample workflow


```yaml
  
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    lint: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint          
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: test code
          id: run-test
          run: npm run test  
        - name: Upload test report
          if: failure() && steps.run-test.outcome == 'failure'
          uses: actions/upload-artifact@v4
          with:
            name: test-report
            path: test.json
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}         
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish 
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'       
         - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
    deploy:
      needs: build
      uses: ./.github/workflows/resusable.yaml # reference workflow in same repo or can be different repo

    report:
      needs: [lint, deploy]
      if: failure()
      runs-on: ubuntu-latest
      steps:
       - name: Output report
         run: |
           echo "something went wrong"
           echo "${{ github }}"
```

#### Adding inputs to reusable workflows

- The inputs section

  ```yaml
  name: Reusable workflow deploy
  on: 
    workflow_call:
      inputs:
         artifact-name: 
            description: Name of the artifacts to deploy
            required: false  # value is optional
            default: dist  # if the input not provided uses this
            type: string # type of input
  jobs:
    deploy:
      runs-on: ubuntu-latest
      steps:
      - name: get code
        uses: actions/download-artifact@v4
        with:
          # we use inputs context object to fetch
          name: ${{ inputs.artifact-name }}
      - name: List files
        run: ls -lrt
      - name: Output info
        run: echo "deploy & upload"
  ```

  - To override the default value in the calling reusable workflow. Check the `deploy` job section
```yaml
  
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    lint: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint          
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: test code
          id: run-test
          run: npm run test  
        - name: Upload test report
          if: failure() && steps.run-test.outcome == 'failure'
          uses: actions/upload-artifact@v4
          with:
            name: test-report
            path: test.json
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}         
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish 
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'       
         - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
    deploy:
      needs: build
      uses: ./.github/workflows/resusable.yaml # reference workflow in same repo or can be different repo
      with:
        artifact-name: distribute-files  # in above upload we do this in under this name
    report:
      needs: [lint, deploy]
      if: failure()
      runs-on: ubuntu-latest
      steps:
       - name: Output report
         run: |
           echo "something went wrong"
           echo "${{ github }}"
```

#### We can also use secrets like inputs

- with the secrets section. secrets can't have default


```yaml
  name: Reusable workflow deploy
  on: 
    workflow_call:
      inputs:
         artifact-name: 
            description: Name of the artifacts to deploy
            required: false  # value is optional
            default: dist  # if the input not provided uses this
            type: string # type of input
      secrets:
         some-secret:
           required: false
  jobs:
    deploy:
      runs-on: ubuntu-latest
      steps:
      - name: get code
        uses: actions/download-artifact@v4
        with:
          # we use inputs context object to fetch
          name: ${{ inputs.artifact-name }}
      - name: List files
        run: ls -lrt
      - name: Output info
        run: echo "deploy & upload"
  ```

- using in the calling reusable workflow

```yaml
#...
    deploy:
      needs: build
      uses: ./.github/workflows/resusable.yaml # reference workflow in same repo or can be different repo
      with:
        artifact-name: distribute-files  # in above upload we do this in under this name
      secrets:
        some-secret: ${{ secrets.some-secret }}
```

#### Outputs with reusable workflows
 - if we assume the reusable workflows as function input would be like argument, output would be like return value.

```yaml
  name: Reusable workflow deploy
  on: 
    workflow_call:
      inputs:
         artifact-name: 
            description: Name of the artifacts to deploy
            required: false  # value is optional
            default: dist  # if the input not provided uses this
            type: string # type of input
      outputs:  #1
        result:
          description: The result of deployment
          # with the job outputs is defined t oreturn output we can finally define this here
          value: ${{ jobs.deploy.outputs.deploy-job-outcome }} # 3 this is taken from the output of step jobs.<job_name>.outputs.<variable-name>
  jobs:
    deploy:
      # to use the output in workflow_call above in reusable workflow we need to add below section to the job
      outputs: # finally this section is added which indicates the output of the job
        deploy-job-outcome: ${{ steps.set-result.outputs.step-result }} # this can be any name,  
      runs-on: ubuntu-latest
      steps:
      - name: get code
        uses: actions/download-artifact@v4
        with:
          # we use inputs context object to fetch
          name: ${{ inputs.artifact-name }}
      - name: List files
        run: ls -lrt
      - name: Output info
        run: echo "deploy & upload"
      - name: Set result output  #2
        run: echo "::set-output name=step-result::success" # this is like pushing the variable to github output variable.
  ```

- using within the reusable workflow

```yaml
#...
    deploy:
      needs: build
      uses: ./.github/workflows/resusable.yaml # reference workflow in same repo or can be different repo
      with:
        artifact-name: distribute-files  # in above upload we do this in under this name
    print-deploy-result:
      needs: deploy
      runs-on: ubuntu-latest
      steps:
       - name: Print deploy output
         run: echo "${{ needs.deploy.outputs.result }} # the result is the output name variable in worflow_call section
```

#### Using Containers for running the workflow

- We define a Docker for the deployment

```yaml
#...

jobs:
  test:
    environment: testing # this is used when using git repo environment variable in settings
    runs-on: ubuntu-latest # we are using runner.
    container:
        image: mcr.micorsoft.com/playwright:v1.25.0-focal # open different browser and tests it. doing this we can avoid manuall installation.
```

```yaml
#...

jobs:
  test:
    environment: testing # this is used when using git repo environment variable in settings
    runs-on: ubuntu-latest # we are using runner.
    container: node:16
```

- passing the image and environment for container

```yaml
#...

jobs:
  test:
    environment: testing # this is used when using git repo environment variable in settings
    runs-on: ubuntu-latest # we are using runner.
    container: 
      image: node:16
      #env: # pass env for the container if required to configure
  # ....
```

##### service containers

 - In above we used a container to create on a job.
 - In some case if the database needs to be created for testing, then we can use service containers.
 - host the testing database as service containers.


```yaml
#...

jobs:
  test:
    environment: testing # this is used when using git repo environment variable in settings
    runs-on: ubuntu-latest # we are using runner.
    container: 
      image: node:16
    services: # one service per job, service runs on its own image
      mongodb: # name for the service, there can be more service
        image: mongo
        env:
          MONOGO_INITDB_ROOT_USERNAME: root #update the same cred in env of the jobs that connect to the db
          MONOGO_INITDB_ROOT_PASSWORD: example
    steps:
      - name: get code
        uses: #...
        
```

#### communicating with service and containers

- we can use the service name of the connection

- Below approach works only the container is used to run the test job which will connect to the service db.

```yaml
#...
jobs:
  test:
    runs-on: ubuntu-latest # we are using runner.
    container: 
      image: node:16
    env:
     MONGODB_CONNECTION_PROTOCOL: monogdb  # name of the service
     MONGODB_CLUSTER_ADDRESS: monogdb      # name of the service
     MONGODB_USERNAME: root
     MONGODB_PASSWORD: example
    services: # one service per job, service runs on its own image
      mongodb: # name for the service, there can be more service
        image: mongo
        env:
          MONOGO_INITDB_ROOT_USERNAME: root #update the same cred in env of the jobs that connect to the db
          MONOGO_INITDB_ROOT_PASSWORD: example
    steps:
      - name: get code
        #...
```

 - Note if the test is not using teh container option, then we need to manually configure the network etc.
 - still we can connect using the localhost, the service should port-froward to some port

 ```yaml
 #...
     env:
      MONGODB_CONNECTION_PROTOCOL: monogdb # name of the  service
      MONGODB_CLUSTER_ADDRESS: 127.0.0.1:27017
     service:
       mongodb:
         image: mongo
         ports:
           - 727017:27017  # port forwarding the service
         env:
           #....
 ```

 #### Custom Actions
- community built actions can be used, but under some circumstense we require our own action to be built. That is where we create custom actions.

 Types of custom actions approaches that can be used to build custom action is listed below
   - Javascript actions => ths is simply writting action in JS
   - Docker actions => create a dockerfile with required configuration.
   - Compisite actions => combine multiple workflow in single compostie actions. Used for grouping and allows for reusing steps. Combine run command and uses.

###### Compisite action (custom actions)
 

- in the below workflow action there are multiple duplicate steps.
  - Option 1: we can create a new repository and build it there and refer it here.
  - Options 2: we can create a actions in local. 
       - Create a folder under the `.github`, the folder can be any name. In this case we create it as `action`.
       - Create another folder under the `action` called `cached-deps`.
       - we need to create an `action.yml` file which will contains the actions.
       
       ```yaml
       # action.yml

       name: 'Get & Cache dependencies'
       description: 'Gets the dependencies 
       (using npm) and caches it'
       runs:
         using: 'composite'  # this must be composite <- tells github action this is a composite 
         steps:
            - name: Cache dependencies
              id: cache
              uses: actions/cache@v3
              with:
                path: node_modules
                key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
            - name: Install dependencies
              if: steps.cache.outputs.cache-hit != 'true'
              run: npm ci
              shell: bash  # we need to specify this for composite
       ```
        - The above snippet of the custom action extracted the cache and dependencies.
        - To use the above custom action (created part of the same repo, we can use the uses)

        ```yaml
        jobs:
          lint:
            runs-on: ubuntu-latest
            steps:
              - name: get code
                uses: actions/checkout@v4
              - name: load cache and dependencies
                uses: ./.github/actions/cached-deps # file since local file, this can be different repo
        ```

- The actual workflow where we can extract the cache into its own custom actions. To create that refer the above steps.
 ```yaml
 name: Deployment
on:
  push:
    branches:
      - main
jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Cache dependencies
        id: cache
        uses: actions/cache@v3
        with:
          path: node_modules
          key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
      - name: Install dependencies
        if: steps.cache.outputs.cache-hit != 'true'
        run: npm ci
      - name: Lint code
        run: npm run lint
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Cache dependencies
        id: cache
        uses: actions/cache@v3
        with:
          path: node_modules
          key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
      - name: Install dependencies
        if: steps.cache.outputs.cache-hit != 'true'
        run: npm ci
      - name: Test code
        id: run-tests
        run: npm run test
      - name: Upload test report
        if: failure() && steps.run-tests.outcome == 'failure'
        uses: actions/upload-artifact@v3
        with:
          name: test-report
          path: test.json
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Cache dependencies
        id: cache
        uses: actions/cache@v3
        with:
          path: node_modules
          key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
      - name: Install dependencies
        if: steps.cache.outputs.cache-hit != 'true'
        run: npm ci
      - name: Build website
        run: npm run build
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: dist-files
          path: dist
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Get build artifacts
        uses: actions/download-artifact@v3
        with:
          name: dist-files
          path: ./dist
      - name: Output contents
        run: ls
      - name: Deploy site
        run: echo "Deploying..."
 ```

- after applying the composite actions to the above snippet, would look like below
 
 ```yaml
 name: Deployment
on:
  push:
    branches:
      - main
jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: load cache and dependencies
        uses: ./.github/actions/cached-deps      
      - name: Lint code
        run: npm run lint
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: load cache and dependencies
        uses: ./.github/actions/cached-deps        
      - name: Test code
        id: run-tests
        run: npm run test
      - name: Upload test report
        if: failure() && steps.run-tests.outcome == 'failure'
        uses: actions/upload-artifact@v3
        with:
          name: test-report
          path: test.json
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: load cache and dependencies
        uses: ./.github/actions/cached-deps        
      - name: Build website
        run: npm run build
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: dist-files
          path: dist
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Get build artifacts
        uses: actions/download-artifact@v3
        with:
          name: dist-files
          path: ./dist
      - name: Output contents
        run: ls
      - name: Deploy site
        run: echo "Deploying..."
 ```

##### Adding inputs to the composite actions custom actions

- To add input to the composite actions, 

  ```yaml
  # action.yml

  name: 'Get & Cache dependencies'
  description: 'Gets the dependencies (using npm) and caches it'
  inputs:
    caching: # name can be anything
      description: 'enable or disable cache dependencies'
      requires: true # to be provided by the user/calller 
      default: `true`
  runs:
    using: 'composite'  # this must be composite <- tells github action this is a composite 
    steps:
      - name: Cache dependencies
        if: inputs.caching == 'true'  # we are checking the input
        id: cache
        uses: actions/cache@v3
        with:
          path: node_modules
          key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
      - name: Install dependencies
        if: steps.cache.outputs.cache-hit != 'true' || input.caching != 'true'
        run: npm ci
        shell: bash  # we need to specify this for composite
  ```

Example on passing input

```yaml
#...
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: load cache and dependencies
        uses: ./.github/actions/cached-deps   
        with:
          caching: 'false' #disable the caching for this job
# ...
```
  
##### Adding outputs to the composite action custom actions

- we will add the outputs field

  ```yaml
  # action.yml

  name: 'Get & Cache dependencies'
  description: 'Gets the dependencies (using npm) and caches it'
  inputs:
    caching: # name can be anything
      description: 'enable or disable cache dependencies'
      requires: true # to be provided by the user/calller 
      default: `true`
  outputs:
    used-cache:
       description: 'cache usage'
       value: ${{ steps.install.outputs.cache }}  # cache is the output using echo
  runs:
    using: 'composite'  # this must be composite <- tells github action this is a composite 
    steps:
      - name: Cache dependencies
        if: inputs.caching == 'true'  # we are checking the input
        id: cache
        uses: actions/cache@v3
        with:
          path: node_modules
          key: deps-node-modules-${{ hashFiles('**/package-lock.json') }}
      - name: Install dependencies
        id: install  #added to identify by the toutputs
        if: steps.cache.outputs.cache-hit != 'true' || input.caching != 'true'
        run: | 
          npm ci
          echo "::set-output name=cache::'${{ inputs.caching }}'"
        shell: bash  # we need to specify this for composite
  ```

Example of using the outputs in steps

```yaml
#...
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: load cache and dependencies
        id: cache-deps  # id added for getting the output of this step
        uses: ./.github/actions/cached-deps   
        with:
          caching: 'false' #disable the caching for this job
      - name: Output info
        run: echo "cache usage: ${{ steps.cache-deps.outputs.used-cache }} # steps.<step-id>.outputs.<composite-action-outputs-variable>
# ...
```

### Creating Javascript custom actions

- Create a folder under `.github`, and as we created `actions` folder for composite, we add new folder `deploy-s3-javascript`.
- under the folder
   - Create an file called `action.yml`
   - Create a file called `main.js` (this can be anything)
- 
```yaml
#action.yml
name: 'deploy to AWS s3'
description: 'deploy the content to aws s3'
runs:
  using: 'node16' #node version, refer doc metadata syntax
                  #github action will identify this as js action
  main: 'main.js' # we add main field here which is different where we specified 'composite'
                  # the file name main.js is specified here
                  # github action will run the js command frm the main.js
                  # we have pre and post field we might need to execut before and after main field.
```

- In order to perform the local development we need to install nodejs and npm. once installed we can use below steps
- navigate to the `<repo>/.github/actions/deploy-s3-javascript` and issue `npm init -y`. 
- we need this step since to output the data in github action we need the github js function to do it. which is fetched from the npm. Issue `npm install @actions/core @actions/github @actions/exec`. all these dependencies are part of the tool-kit of github action.
- We can see the `pacakge.json` and see the version added


```js
//main.js
const core= require('@actions/core')
const github = require('@actions/github')
const exec = require('@actions/exec')

//create a function the name can be different
function run(){
  //main code
  //log a message
  core.notice('this is printed from javascript action')

}
run();
```

- To use the javascript custom action in the workfow

```yaml
# ./.github/workflow/
#...
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: load cache and dependencies
        id: cache-deps  # id added for getting the output of this step
        uses: ./.github/actions/cached-deps   
        with:
          caching: 'false' #disable the caching for this job
      - name: Output info
        run: echo "cache usage: ${{ steps.cache-deps.outputs.used-cache }} # steps.<step-id>.outputs.<composite-action-outputs-variable>
   # ...
   deploy:
     needs: build
     runs-on: ubuntu-latest
     steps: 
      - name: get code
        uses: actions/checkout@v4
      #...
   information:
      runs-on: ubnutu-latest
      steps:
        - name: Get code
          uses: actions/checkout@v3 # this step is required since without this the build will fail
        - name: Run custom action javascript
          uses: ./.github/actions/deploy-s3-javascript
```

commit the changes to the github. note that node_modules needs to be include the dependencies to the git hub. The gitghub requrires all the dependencies for proper functioning.

##### Adding inputs to the javascript custom actions

```yaml
# action.yml
name: 'deploy to AWS s3'
description: 'deploy the content to aws s3'
inputs:
  bucket:
    description: 'The s3 bucket name'
    required: true
  bucket-region:
    description: 'The region of S3'
    required: false
    default: 'us-east-1'
runs:
  using: 'node16'
  main: 'main.js'

```

- The main.js update

```js
//main.js
const core= require('@actions/core')
const github = require('@actions/github')
const exec = require('@actions/exec')

//create a function the name can be different
function run(){
  //main code
  // get input values

  const bucket = core.getInput('bucket', {required: true});
  const bucketRegion = core.getInput('bucket-region',{required: true});
  const distFolder = core.getInput('dist-folder',{required: true});

  //upload file
  // we can use the aws sdk or github exec package
  exec.exec('echo "executing command"');
  //exec command has aws cli
  //exec.exec('aws s3 sync <local-folder> <s3-bucket>');
  const s3uri=`s3://${bucket}`; //js dynamic string template
  exec.exec(`aws s3 sync ${distFolder} ${s3uri} --region ${bucketRegion}` );

  //the github variable provide lib to upload data to github
  // using github rest api
  //github.getOctokit().auth
  //github.context() //some of the context info can be fetched
  //log a message
  core.notice('this is printed from javascript action')

}
run();
```

- Using the javascript actions

```yaml
# ./.github/workflow/
#...
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: load cache and dependencies
        id: cache-deps  # id added for getting the output of this step
        uses: ./.github/actions/cached-deps   
        with:
          caching: 'false' #disable the caching for this job
      - name: Output info
        run: echo "cache usage: ${{ steps.cache-deps.outputs.used-cache }} # steps.<step-id>.outputs.<composite-action-outputs-variable>
   # ...
   deploy:
     needs: build
     runs-on: ubuntu-latest
     steps: 
      - name: get code
        uses: actions/checkout@v4
      - name: deply site
        uses: ./.github/actions/deploy-s3-javascript
        env: # step specific env variable
          AWS_ACCESS_KEY_ID: ${{ secret.AWS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secret.AWS_ACCESS }}
        with:
          bucket: bucket-name
          dist-folder: ./dist
          bucket-region: us-east-1
```

- Note with the `aws s3 sync` can't upload the files, we need to create accesskey. How to set this variable, we can set it as an environment variable. The AWS CLI will look for the environment variable. `AWS_ACCESS_KEY_ID`.

#### Adding output to the javascript custom actions

- They dynamic url to be generated as output in the github action logs.

```yaml
# action.yml
name: 'deploy to AWS s3'
description: 'deploy the content to aws s3'
inputs:
  bucket:
    description: 'The s3 bucket name'
    required: true
  bucket-region:
    description: 'The region of S3'
    required: false
    default: 'us-east-1'
outputs:
  website-url: 
    description: 'The url of the deployed website'
    # Note we are not setting the output from the steps
    # like how we set in composite actions
runs:
  using: 'node16'
  main: 'main.js'
```

- The output is set in the main.js code

```js
//main.js
const core= require('@actions/core')
const github = require('@actions/github')
const exec = require('@actions/exec')

//create a function the name can be different
function run(){
  //main code
  // get input values

  const bucket = core.getInput('bucket', {required: true});
  const bucketRegion = core.getInput('bucket-region',{required: true});
  const distFolder = core.getInput('dist-folder',{required: true});

  //upload file
  // we can use the aws sdk or github exec package
  exec.exec('echo "executing command"');
  //exec command has aws cli
  //exec.exec('aws s3 sync <local-folder> <s3-bucket>');
  const s3uri=`s3://${bucket}`; //js dynamic string template
  exec.exec(`aws s3 sync ${distFolder} ${s3uri} --region ${bucketRegion}` );

   const websiteDynamicUrl = `http://${bucket}.s3-website-${bucketRegion}.amazonaws.com`;
   core.setOutput('website-url',websitDynamicUrl);
}
run();
```
- To print the info in the step and show how to use it


```yaml
   # ...
   deploy:
     needs: build
     runs-on: ubuntu-latest
     steps: 
      - name: get code
        uses: actions/checkout@v4
      - name: deply site
        id: deploy  # added to get the output
        uses: ./.github/actions/deploy-s3-javascript
        env: # step specific env variable
          AWS_ACCESS_KEY_ID: ${{ secret.AWS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secret.AWS_ACCESS }}
        with:
          bucket: bucket-name
          dist-folder: ./dist
          bucket-region: us-east-1
     - name: Output url info
       run: |
         echo "website url: ${{ steps.deploy.outputs.website-url }}
```

### Docker action custom action

- Create a folder under the `.github`, then `actions` (like in the above example)
- Create a folder `deploy-s3-docker`, then create a file 
- we use a python code to update the logic. 
- Create python file `deployment.py` in the `deploy-s3-docker` folder

- deployment.py
```py
import os
import boto3
import mimetypes
from botocore.config import Config


def run():
    bucket = os.environ['INPUT_BUCKET']
    bucket_region = os.environ['INPUT_BUCKET-REGION']
    dist_folder = os.environ['INPUT_DIST-FOLDER']

    configuration = Config(region_name=bucket_region)

    s3_client = boto3.client('s3', config=configuration)

    for root, subdirs, files in os.walk(dist_folder):
        for file in files:
            s3_client.upload_file(
                os.path.join(root, file),
                bucket,
                os.path.join(root, file).replace(dist_folder + '/', ''),
                ExtraArgs={"ContentType": mimetypes.guess_type(file)[0]}
            )

    website_url = f'http://{bucket}.s3-website-{bucket_region}.amazonaws.com'
    # The below code sets the 'website-url' output (the old ::set-output syntax isn't supported anymore - that's the only thing that changed though)
    with open(os.environ['GITHUB_OUTPUT'], 'a') as gh_output:
        print(f'website-url={website_url}', file=gh_output)


if __name__ == '__main__':
    run()

```

- we have a Dockerfile that uses the deployment.py 

```Dockerfile
FROM python:3

COPY requirements.txt /requirements.txt

RUN pip install -r requirements.txt

COPY deployment.py /deployment.py

CMD ["python", "/deployment.py"]
```

- The `action.yml` the action details would be same as the `javascript custom action`

```yaml
# action.yml
name: 'deploy to AWS s3'
description: 'deploy the content to aws s3'
inputs:
  bucket:
    description: 'The s3 bucket name'
    required: true
  bucket-region:
    description: 'The region of S3'
    required: false
    default: 'us-east-1'
outputs:
  website-url: 
    description: 'The url of the deployed website'
runs:
  using: 'docker'
  image: 'Dockerfile'  # this is not main like in javascript
```
 **NOTE:** The input and output definition is same as the javascript custom action. The way these outputs are used in the python code is different. They are configured as environment variables.
 - To access environment variables in the python, the github generates the input as environment variable. The variable name of the env will be upper case, `INPUT_<upper-case-input-variable-name>`. Example, `INPUT_BUCKET`, `INPUT_BUCKET-REGION`, etc.
- In python, we use `os.environ['INPUT_BUCKET]`.

- The output in the python is similar to the action where we use the `print(f'::set-output name=website-url::{websut_url}')`. Refer the deployment.py in the above code snippet.


- How to use the custom actions in workflow

```yaml
   # ...
   deploy:
     needs: build
     runs-on: ubuntu-latest
     steps: 
      - name: get code
        uses: actions/checkout@v4
      - name: deply site
        id: deploy  # added to get the output
        uses: ./.github/actions/deploy-s3-docker
        env: # step specific env variable
          AWS_ACCESS_KEY_ID: ${{ secret.AWS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secret.AWS_ACCESS }}
        with:
          bucket: bucket-name
          dist-folder: ./dist
          bucket-region: us-east-1
     - name: Output url info
       run: |
         echo "website url: ${{ steps.deploy.outputs.website-url }}
```
