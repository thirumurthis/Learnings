### Parallel vs Sequence:
  - To run github action job or step in sequential we use `needs` 

- Context and expression:
  - To output github contexts 

  ```yaml
   name: Github context info
   on: workflow_dispatch
   jobs: 
     output-info:
       runs-on: ubuntu-latest
       steps:
        - name: Output Github context
          run: echo "${{ toJSON(github) }}"  # github is reserved key name we use github action function
  ```


> Info:
> - If we have a local git repo for a project, and we need to associate to the github repository newly created in github UI. Then using `git remote add origin https://<username>@github.com/<username>/new-git-repo`


### Events:
  - Available events 
     - Repository releated - mostly like push, pull_request, create, fork, issues, watch, discussions, issue_comment, etc
     - Other Events - workflow_dispatch, repository_dispatch, schedule, workflow_call, etc 
  - Refer the github documentation for more events.

  - To utlized more than one event for job we can use yaml list

  ```yaml
  name: Events info
  on: [push, workflow_dispatch]
  jobs:
    deploy:
      runs-on: ubuntu-latest
      steps:
       - name: Output event context
         run: echo "${{ toJSON(github.event) }}"
  ``` 
- Event Activity Types and Filters:
  - If we want more control, like if trigger only on specific branch we might use the activity types of that event.
  - We can use filters as well to control the trigger.
     - Sample push filter `on.push.<branches|tags|branches-ignore|tags-ignore>`
     - Sample push filter `on.<push|pull_request|pull_request_target>.<paths|paths-ignore>
  - Check documentation for more activites on the event.
  - For example, the Pull event has activity types - open, closed, edited.
  - For example, the push event has filters based on target branch.

  ```yaml
   name: Events Sample
   on:
     pull_request:
      types:
        - opened
        - closed
      branches: # specify the branch trigger only for listed branch or expression
        - main
        - PR-*  # branch starts with PR-, ex. PR-000-test
        - feature/**  # ** allows / after the feature/, ex- feature/test/one
     workflow_dispatch:
     push:
       branches: # specify the branch trigger only for listed branch or expression
        - main
        - PR-*  # branch starts with PR-, ex. PR-000-test
        - feature/**  # ** allows / after the feature/, ex- feature/test/one
       paths:
         - '**.java'  # This indicates the workflow will be triggered only if on of the java file is updated
       paths-ignore:
         - '.github/workflows/*'

   jobs:
     deploy:
      runs-on: ubuntu-latest
      steps:
        - name: Output info
          run: echo "$ {{ toJSON(github.event) }}"
  ```

  - Skipping the CI when we use the push or pull events
   - Say if we are making changes to the code just on the comment we might not need the Github actions workflow to be executed. In that case when we commit the code, we can use `[skipt ci]`,`[ci skip]`,`[no ci]`,`[skip actions]`,`[actions skip]`. Alternatively, we can add the following at the end of the commit with 2 empty lines. `skip-checks:true`, `skip-checks: true`.

#### Job Data & outputs 
- Working with artifact
- Working with job outputs
- Caching Dependencies

  - Lets say of a job that build a website will produce an output. The output could be executable or other formats, or to be uploaded to appstore/artifactory. The output generated by the job is called output assests. The artifacts can be stored manually or automatically.


  ```yaml
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: Test code
          run: npm run test
    build:
      needs: test
      runs-on: ubuntu-latest
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
             package.json  # this is an example
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files # the build artifact is zip this will unzip 
       - name: list the content
         run: ls -lrth
       - name: deploy
         run: echo "deploy.."
  ```
   - under the github actions, we should be able to see the artifacts section with artifact to download in local.

   - Note the artifacts produced by the build job is not available to deploy job. Since both runs on different machines

   - To download we need to use the action `download-artifacts`

#### Job outputs to be available to other jobs

- Say the artifact name of a file created in build job to be available in deploy job below.

  ```yaml
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: Test code
          run: npm run test
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish  # this is required so the output will use it
         # the outputs above we have set the script-file variable.
         # GITHUB_OUTPUT is a special variable
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'
         # alternatively we can use below without use of GITHUB_OUTPUT. Below was old way to do but as best practice use above github_output approach
         #run: find dist/assets/*.js -type f -execdir echo '::set-output name=script-file::{}' ';'
       - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
             package.json  # this is an example
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files # the build artifact is zip this will unzip 
       - name: list the content
         run: ls -lrth
       - name: Output the filename from build job
         # we use needs object check doc, since this contains ouput of all the jobs needs.<job-name>.output.<variable>
         run: echo "${{ needs.build.outputs.script-file }}
       - name: deploy
         run: echo "deploy.."
  ```

### Depenency caching
- The depnedncies can be cached from one job to another job. Refer the above the build and test has the install dependency.
- we can use `action/cache@v4`

```yaml
  name: Deploy website
  on: 
    push: 
      branches:
        - main
  jobs:
    test: 
      runs-on: ubuntu-latest
      steps:
        - name: checkout code
          uses: actions/checkout@v4
        - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}  # used to retreive and cached in runner instance
             # hasFiles function will generate has when the files are changed.
             # when the package.json file change, then different hash key will be different so chace will not be used and install dependencies will install new dependencies.
             # after the job is completed, the cache will be updated for new dependency
             # different project has different cache option refer document.
        - name: Install dependencies
          run: npm ci
        - name: Lint code
          run: npm run lint
        - name: Test code
          run: npm run test
    build:
      needs: test
      runs-on: ubuntu-latest
      # outputs 
      outputs:
         script-file: ${{ steps.publish.outputs.script-file }}
      steps:
       - name: checkout code
         uses: action/checkout@v4
       - name: cache dependencies
          uses: actions/cache@v4
          with:
             path: ~/.npm  # this is the path used by npm in ubuntu
             key: deps-node-modules-${{ hashFiles('**/package-lock.json) }}         
       - name: Install dependencies
         run: npm ci
       - name: build source
         run: npm run build
       # start of custom actions
       - name: Publish javascript filename
         id: publish  # this is required so the output will use it
         # the outputs above we have set the script-file variable.
         # GITHUB_OUTPUT is a special variable
         run: find dist/assets/*.js -type f -execdir echo 'script-file={}' >> $GITHUB_OUTPUT ';'
         # alternatively we can use below without use of GITHUB_OUTPUT. Below was old way to do but as best practice use above github_output approach
         #run: find dist/assets/*.js -type f -execdir echo '::set-output name=script-file::{}' ';'
       - name: upload artifact
         uses: actions/upload-artifact@v4 # check the doc
         with:
           name: distribute-files
           path: |
             dist
             package.json  # this is an example
    deploy:
      needs: build
      runs-on: ubuntu-latest
      steps:
       - name: Get build artifacts
         uses: actions/download-artifacts@v4
         with:
           name: distrbute-files # the build artifact is zip this will unzip 
       - name: list the content
         run: ls -lrth
       - name: Output the filename from build job
         # we use needs object check doc, since this contains ouput of all the jobs needs.<job-name>.output.<variable>
         run: echo "${{ needs.build.outputs.script-file }}
       - name: deploy
         run: echo "deploy.."
```