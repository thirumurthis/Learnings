After setting up the nodes as  in example [Link](https://github.com/thirumurthis/Learnings/blob/master/K8s/Kubernetes_cluster_notes.md).

##### To setup the kubectl command:
  - In case of the lab with 1 master 2 worker, just scp the admin.conf from the master /etc/kubernets/ to the host machine.
  
##### Once copied check/validate with below commands:
```
$ kubectl version
Client Version: version.Info{Major:"1", Minor:"17", GitVersion:"v1.17.0", GitCommit:"70132b0f130acc0bed193d9ba59dd186f0e634cf", GitTreeState:"clean", BuildDate:"2019-12-07T21:20:10Z", GoVersion:"go1.13.4", Compiler:"gc", Platform:"windows/amd64"}
Server Version: version.Info{Major:"1", Minor:"18", GitVersion:"v1.18.3", GitCommit:"2e7996e3e2712684bc73f0dec0200d64eec7fe40", GitTreeState:"clean", BuildDate:"2020-05-20T12:43:34Z", GoVersion:"go1.13.9", Compiler:"gc", Platform:"linux/amd64"}
```
```
$ kubectl version --short
Client Version: v1.17.0
Server Version: v1.18.3
```
```
$ kubectl cluster-info
Kubernetes master is running at https://172.42.42.100:6443
KubeDNS is running at https://172.42.42.100:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
```

#### First program to run in pod:

Create a yml file with nginx container (demo1.yml).
 
```yaml
apiVersion: v1

kind: Pod
metadata:
   name: myapp-pod
   labels:
     app: myapp
     type: testpod

spec:
    containers:
     - name: nginx-container
       image: nginx
```

##### To create pod using the `kubectl` command
```
$ kubectl create -f demo1.yml
pod/myapp-pod created
```

##### To check the status of deployed pod

- The status of the pod 'Pending` or `ContainerCreating`
```
C:\thiru\learn\k8s\certs\prog1>kubectl get pods
NAME        READY   STATUS              RESTARTS   AGE
myapp-pod   0/1     ContainerCreating   0          8s
```
Note: `READY` states that the Number of running container/ total number of container.

- The status of the pod after created `Running` 
```
C:\thiru\learn\k8s\certs\prog1>kubectl get pods
NAME        READY   STATUS    RESTARTS   AGE
myapp-pod   1/1     Running   0          40s
```

#### Creating an pod directly without yml file
```
$ kubectl run nginix --image=ngnix
```

#### To get the information of the pods running on which node.
```
$ kubectl get pods -o wide
```

#### To get the images used in the pod
```
$ kubectl describe pod <pod-name>
```

#### Given the pod edit it with necessary value.
```
$ kubectl edit pod <pod-name>
## this command opens up the vi with the pod info that was generated by the Kuberentes internally.
```

##### kubectl apply 
```
$ kubectl apply -f <pod-descriptor file>
```

#### Comand to get the yaml file for a given pod
```
$ kubectl get pod <pod-name> -o yaml  > file-to-redirect.yml
```

### Managing Labels:
##### After the pod is running how to view the label name.
  - The labels are already added in the Pod manifest yaml file (firstapp.yml).
 ```
 $ kubectl get pod myapp-pod --show-labels
 NAME        READY   STATUS    RESTARTS   AGE   LABELS
 myapp-pod   1/1     Running   0          46s   app=myapp,type=testpod
 ```
 
 ##### `Adding a label to a pod` running in the node.
 ```
 C:\thiru\learn\k8s\certs\prog1>kubectl label pod myapp-pod env=demo1
 pod/myapp-pod labeled

 C:\thiru\learn\k8s\certs\prog1>kubectl get pod myapp-pod --show-labels
 NAME        READY   STATUS    RESTARTS   AGE     LABELS
 myapp-pod   1/1     Running   0          5m54s   app=myapp,env=demo1,type=testpod
 ```
 
 ##### `Removing label to a pod` running in the node.
 ```
 ## Note the - sign at the end
 C:\thiru\learn\k8s\certs\prog1>kubectl label pod myapp-pod env-
 pod/myapp-pod labeled

  C:\thiru\learn\k8s\certs\prog1>kubectl get pod myapp-pod --show-labels
  NAME        READY   STATUS    RESTARTS   AGE     LABELS
  myapp-pod   1/1     Running   0          7m36s   app=myapp,type=testpod
 ```
 
 ##### `Overwrite/update the label to a pod` running in the node.
  - add a label first as env=dev-demo1 and then update that to env=dev1
 ```
C:\thiru\learn\k8s\certs\prog1>kubectl get pod myapp-pod --show-labels
NAME        READY   STATUS    RESTARTS   AGE   LABELS
myapp-pod   1/1     Running   0          10m   app=myapp,env=dev-demo1,type=testpod

C:\thiru\learn\k8s\certs\prog1>kubectl label --overwrite pods myapp-pod env=dev1
pod/myapp-pod labeled

C:\thiru\learn\k8s\certs\prog1>kubectl get pod myapp-pod --show-labels
NAME        READY   STATUS    RESTARTS   AGE   LABELS
myapp-pod   1/1     Running   0          11m   app=myapp,env=dev1,type=testpod
 ```

##### Another representation of label overwrite command
```
## note the pod/<pod-name> representation
$ kubectl label pod/myapp-pod env=demo --over-write
```

### `Searching` using labels.
 - When manifest with many pods defined with labels and those are running.
 
```
## Say we need to know the list of pods that are having the label env=demo

$ kubectl get pods --selector env=demo

## To display the labels of the selector

$ kubectl get pods --selector env=demo --show-labels

```

##### How to apply multiple labels in the selector, when searching for pods
```
# the below will find the pods that contains the labels as stated with comma separated value.
$ kubectl get pods --selector env=demo,app=myapp
```

##### Applying `!=` search in the selector
```
# note the != in the selector
$ kubectl get pods --selector env!=demo,tier=front-end
```

### `--selector` has a short form `-l`, lets use this in searching with set operator using `in`
```
## use " quotes when using from windows, since using ' reports exception "name cannot be provided for selector"
$ kubectl get pods -l "version in (1.0,2.0)"

```
##### using `notin` within selector
```
$ kubectl get pods -l "version notin (1.0,2.0)"
```

##### Performing delete for a group of lables 
```
## below will delete all the pods that has the matchin label env=demo
## note the resource name pods in this case. (it can be deployment, services, etc.)
 $ kubectl delete pods -l env=demo
```

##### `Delete all pods`
```
$ kubectl delete pods --all
```

Note: if there are some deployments associated to the pod, stop the deployment and then delete the pod.

##### `readinessProbe` 
  - Used to know when the container is ready to take up the traffic.
```yaml 
    readinessProbe:
          initialDelaySeconds: 10
          timeoutSeconds: 1
          # Probe for http
          httpGet:
            # Path to probe
            path: /
            # Port to probe
            port: 80
```

##### `livenessProbe`
```yaml
        livenessProbe:
          initialDelaySeconds: 10
          timeoutSeconds: 1
          # Probe for http
          httpGet:
            # Path to probe
            path: /
            # Port to probe
            port: 80
```

With the `livenessProbe`, the Pods and Deployment will be in running state, but notice the RESTARTS of the pods. In this case the pods will be restarted often.
  - At some point the pod will land up or goes to __`CrashLoopBackOff`__ status
 
 
#### How to investigate what went wrong in the pod or deployment, using `describe`: 
```
## under the event section should be able to see the log message
## container info will be available over here too ( -o wide)
$ kubectl describe pod <pod-name>
```

#### How to upgrade the deployment.
  - Say we have deployed a application with image version 1.0, using `$ kubectl create -f <deployment.yaml>` file.
  - If we have the image updated with the new version, we simply set the image to the deployment, like below:
  ```
  $ kubectl set image deployment/<previous-deployment-name> <new-image-version-name>
  ```
  - After setting the image, if we see the deployment, the new deployment is pdated.
  - At this moment, if you see the replicasets `$ kubectl get rs` should see two set of pods.
       - where there are two unique guid attached, and one is at the desired state with 1 or more replica set.
       
NOTE:
  - if the create command is started with `--record` option (will record)
  - after setting the latest version of image
  - using the command `$ kubectl rollout history deployment/<deployment-name>` will display the changes happened on the deployment, the revision happened.
  
##### How to `rollout` to the previous version  
```
$ kubectl rollout undo deployment/<deployment-name>
```

##### if we need to rollout to a specific version, then use
```
$ kubectl rollout undo deployment/<deployment-name> --to-revision=<version-number>
```

#### Troubleshooting the pods:
```
## from deployment perspective
$ kubectl describe deployment <deployment-name>
```

```
## pod name is obtained using kubectl get pod command
$ kubectl describe po/<pod-name>

or 

$ kubectl describe pod <pod-name>

## check the Events section which has the messages and info
```

#### Troubleshooting using the `logs` files:
```
## get the deployments info using kubectl get deployments.
## get the associated pods for that specific deployments. <pod-name>

$ kubectl logs <pod-name>
## the above command will return logs info of the pod
```

#### Trobuleshooting inside the pod itself using `exec` command:
```
## below command will take to the pod itself.
$ kubectl exec -it <pod-name> /bin/bash
root@pod-name:/#
```
##### Since we have multiple containers with the pod, in that case we need to exec to that container use below command `-c <pod-name>`
```
$ kubectl exec -it <pod-name> -c <pod-name-without-uid> /bin/bash
```
